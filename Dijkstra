#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#define max 1000

int main(void)
{
    printf("开始生成无向带权图\n");
int n;
while(1){
printf("请输入图的节点数(须大于1)：\n");
scanf("%d",&n);
if(n>1)
    break;
        }
        printf("开始生成%d点无向图\n",n);
        int str[n][n],lujing[n][n];
int i=0,j=0,k=0,m;
for(i=0;i<n;i++)
    for(j=0;j<n;j++){
    str[i][j]=0;
    lujing[i][j]=0;
    }/**数组初始化*/
for(i=0;i<n;i++)
{


    printf("请输入由该节点(第%d个)出发的边指向的节点的序号(输入0或者%d退出)：\n",i+1,i+1);
    while(1)
    {
        printf("请输入目标节点的序号\n");
        scanf("%d",&j);
        if(j&&j!=i+1){
                printf("请输入该边的权值\n");
        scanf("%d",&m);
        str[i][j-1]=m;
        str[j-1][i]=m;
        lujing[i][j-1]=1;
        lujing[j-1][i]=1;
        }
        else
            break;
    }
}
/**输出矩阵*/
printf("输出邻接矩阵\n");
for(i=0;i<n;i++)
{printf("第%5d条边：",i+1);
    for(k=0;k<n;k++)
    {
        printf(" %d",str[i][k]);
    }
    printf("\n");
}




/**迪克斯特拉算法*/
printf("请输入需要计算的起点和终点：\n");
scanf("%d %d",&i,&j);
printf("%d %d\n",i,j);
int min=0,q=0;
int L[n];
int S[n];
for(q=0;q<n;q++)
    {S[q]=0;
    L[q]=max;///将所有点的通路长度标记为max 1000
    }
    L[i-1]=0;///i点的长度为0
while(S[j-1]==0)///当j点不属于S时
///for(int a=0;a<n;a++)
{
    k=0;
   while(S[k]==0)
    k++;
   min=max;
for(q=0;q<n;q++)
    {if((S[q]==0)&&(L[q]<=min))///将不属于S的L最小的点找出来,
    {

    m=q;
    min=L[q];}
    }
    S[m]=1;///将第q条边收入S集合中
    for(q=0;q<n;q++)
    {
        if(S[q]==0)///对于所有不属于S的点
        {
            if(S[q]==0&&(lujing[min][q])&&((min+str[min][q])<L[q]))///q代表任一不属于S的点，min代表L最小的点
            {
                L[q]=min+str[min][q];
            }///给S添加带最小标记的点，并且更新不在S里面的顶点的标记

        }
    }

}
printf("最短路径为：%d\n",L[j-1]);
}

